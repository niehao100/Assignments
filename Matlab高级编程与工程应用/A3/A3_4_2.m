close all;clear all;clc;load face;filename = 'faces.jpg';image = imread(filename);% 先对图像进行分块，试图寻找可能存在人脸的区域imgsize = size(image);    % 确定分块大小imgsize = imgsize(1:2);blocksize = round(min(imgsize)/20);M = floor(imgsize(1)/blocksize);N = floor(imgsize(2)/blocksize);for L = 3:5;    L    image = imread(filename);    img = uint32(floor(double(image)/256*(2^L)));   % 对RGB空间进行缩放    bits = bitsll(img(:,:,1),2*L)+bitsll(img(:,:,2),L)+img(:,:,3);  % 映射    if L==3 % 确定使用的标准        v = v3;        threshold = 0.25;    elseif L==4        v = v4;        threshold = 0.38;    else        v = v5;        threshold = 0.55;    end    dists = zeros(M,N);    for m = 1:M        for n = 1:N            block = bits((m-1)*blocksize+1:m*blocksize,(n-1)*blocksize+1:n*blocksize,:);            stat = histc(block(:),0:8^L-1);            u = stat'/sum(stat);            dists(m,n) = 1-sum(sqrt(u.*v));        end    end    % 找到以后在一定范围内寻找距离最小的区域    while true        [Y,m] = min(dists);        [Y,n] = min(Y);        m = m(n);   % 找到距离最小的一块，在附近寻找人脸        faces = zeros(0,4);        mindist = 1;        step = round(blocksize/3);        num = 3;        range = num*round(blocksize/step);        dists(max(1,m-2*num):min(M,m+2*num),max(1,n-2*num):min(N,n+2*num)) = 1;        halfwidth = round(blocksize/50);        faceend = length(faces);        for a = max(m*blocksize-range*step,1):step:...                min(m*blocksize+(range-1)*step,imgsize(1)-step)            for b = max(n*blocksize-range*step,1):step:...                    min(n*blocksize+(range-1)*step,imgsize(2)-step)                for c = a+2*blocksize:step:min(m*blocksize+range*step,imgsize(1))                    for d = b+2*blocksize:step:min(n*blocksize+range*step,imgsize(2))                        block = bits(a:c,b:d);                        stat = histc(block(:),0:8^L-1);                        u = stat'/sum(stat);                        dist = 1-sum(sqrt(u.*v));                        if dist<mindist                            faces(faceend+1,:) = [a b c d];                            mindist = dist;                        end                    end                end            end        end        if mindist>threshold            last = mindist    figure;    imshow(image);            break;        else            %　画出脸的区域            mindist            face = faces(end,:);            image(max(1,face(1)-halfwidth):min(imgsize(1),face(3)+halfwidth),max(1,face(2)-halfwidth):min(imgsize(2),face(2)+halfwidth),1) = 255;            image(max(1,face(1)-halfwidth):min(imgsize(1),face(3)+halfwidth),max(1,face(4)-halfwidth):min(imgsize(2),face(4)+halfwidth),1) = 255;            image(max(1,face(1)-halfwidth):min(imgsize(1),face(1)+halfwidth),max(1,face(2)-halfwidth):min(imgsize(2),face(4)+halfwidth),1) = 255;            image(max(1,face(3)-halfwidth):min(imgsize(1),face(3)+halfwidth),max(1,face(2)-halfwidth):min(imgsize(2),face(4)+halfwidth),1) = 255;            image(max(1,face(1)-halfwidth):min(imgsize(1),face(3)+halfwidth),max(1,face(2)-halfwidth):min(imgsize(2),face(2)+halfwidth),2:3) = 0;            image(max(1,face(1)-halfwidth):min(imgsize(1),face(3)+halfwidth),max(1,face(4)-halfwidth):min(imgsize(2),face(4)+halfwidth),2:3) = 0;            image(max(1,face(1)-halfwidth):min(imgsize(1),face(1)+halfwidth),max(1,face(2)-halfwidth):min(imgsize(2),face(4)+halfwidth),2:3) = 0;            image(max(1,face(3)-halfwidth):min(imgsize(1),face(3)+halfwidth),max(1,face(2)-halfwidth):min(imgsize(2),face(4)+halfwidth),2:3) = 0;        end    endend